import Campaign from '../models/Campaign';
import CampaignRecipient from '../models/CampaignRecipient';
import ContactListMember from '../models/ContactListMember';
import ContactList from '../models/ContactList';
import Customer from '../models/Customer';
import Conversation from '../models/Conversation';
import Message from '../models/Message';
import { AppError } from '../middleware/error.middleware';
import { campaignQueue } from '../queues/campaign.queue';
import { phoneSettingsService } from './phoneSettings.service';
import { aiBehaviorService } from './aiBehavior.service';
import axios from 'axios';

// Voice ID mapping for ElevenLabs
const VOICE_ID_MAP: Record<string, string> = {
  'adam': 'pNInz6obpgDQGcFmaJgB',
  'alice': 'Xb7hH8MSUJpSbSDYk0k2',
  'antoni': 'ErXwobaYiN019PkySvjV',
  'arnold': 'VR6AewLTigWG4xSOukaG',
  'bill': 'pqHfZKP75CvOlQylNhV4',
  'bella': 'EXAVITQu4vr4xnSDxMaL',
  'elli': 'MF3mGyEYCl7XYWbV9V6O',
  'josh': 'TxGEqnHWrfWFTfGW9XjX',
  'liam': 'TX3LPaxmHKxFdv7VOQHJ',
  'domi': 'AZnzlk1XvdvUeBnXmlld',
};

export class CampaignService {
  async findAll(filters: any = {}, page = 1, limit = 20) {
    const query: any = {};

    if (filters.status) {
      query.status = filters.status;
    }

    const skip = (page - 1) * limit;
    const total = await Campaign.countDocuments(query);

    const campaigns = await Campaign.find(query)
      .populate('listId', 'name')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    // Get stats for each campaign
    const campaignsWithStats = await Promise.all(
      campaigns.map(async (campaign: any) => {
        const stats = await this.getCampaignStats(campaign._id);
        return {
          ...campaign,
          stats
        };
      })
    );

    return {
      items: campaignsWithStats,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    };
  }

  async findById(campaignId: string) {
    const campaign = await Campaign.findById(campaignId)
      .populate('listId', 'name')
      .lean();

    if (!campaign) {
      throw new AppError(404, 'NOT_FOUND', 'Campaign not found');
    }

    const stats = await this.getCampaignStats(campaignId);

    return {
      ...campaign,
      stats
    };
  }

  async create(campaignData: any) {
    try {
      // Log incoming data for debugging
      console.log('Creating campaign with data:', JSON.stringify(campaignData, null, 2));

      // Validate required fields
      if (!campaignData.name) {
        throw new AppError(400, 'VALIDATION_ERROR', 'Campaign name is required');
      }

      if (!campaignData.listId) {
        throw new AppError(400, 'VALIDATION_ERROR', 'Contact list is required');
      }

      if (!campaignData.communicationTypes || campaignData.communicationTypes.length === 0) {
        throw new AppError(400, 'VALIDATION_ERROR', 'At least one communication type is required');
      }

      // Validate communication type specific requirements
      if (campaignData.communicationTypes.includes('sms') && !campaignData.smsBody?.message) {
        throw new AppError(400, 'VALIDATION_ERROR', 'SMS message is required when SMS is selected');
      }

      if (campaignData.communicationTypes.includes('email') && (!campaignData.emailBody?.subject || !campaignData.emailBody?.body)) {
        throw new AppError(400, 'VALIDATION_ERROR', 'Email subject and body are required when Email is selected');
      }

      // Check if list exists (but don't fail if ContactList model has issues)
      try {
        const list = await ContactList.findById(campaignData.listId);
        if (!list) {
          throw new AppError(404, 'NOT_FOUND', 'Contact list not found');
        }
      } catch (listError: any) {
        console.error('Error checking contact list:', listError.message);
        // Continue anyway - list validation is secondary
      }

      const campaign = await Campaign.create({
        ...campaignData,
        status: campaignData.scheduledAt ? 'scheduled' : 'draft'
      });

      console.log('Campaign created successfully:', campaign._id);

      // Schedule campaign if scheduledAt is provided
      if (campaignData.scheduledAt) {
        const scheduledDate = typeof campaignData.scheduledAt === 'string' 
          ? new Date(campaignData.scheduledAt) 
          : campaignData.scheduledAt;
        await this.scheduleCampaign((campaign._id as any).toString(), scheduledDate);
      }

      return campaign;
    } catch (error: any) {
      console.error('Error in campaign.create:', error);
      
      if (error instanceof AppError) {
        throw error;
      }
      
      if (error.name === 'ValidationError') {
        const messages = Object.values(error.errors).map((err: any) => err.message).join(', ');
        throw new AppError(400, 'VALIDATION_ERROR', messages);
      }
      
      throw new AppError(500, 'INTERNAL_ERROR', error.message || 'Failed to create campaign');
    }
  }

  async update(campaignId: string, campaignData: any) {
    const campaign = await Campaign.findById(campaignId);

    if (!campaign) {
      throw new AppError(404, 'NOT_FOUND', 'Campaign not found');
    }

    // Can only update draft or scheduled campaigns
    if (!['draft', 'scheduled'].includes(campaign.status)) {
      throw new AppError(400, 'VALIDATION_ERROR', 'Cannot update campaign in current status');
    }

    Object.assign(campaign, campaignData);
    await campaign.save();

    return campaign;
  }

  async delete(campaignId: string) {
    const campaign = await Campaign.findById(campaignId);

    if (!campaign) {
      throw new AppError(404, 'NOT_FOUND', 'Campaign not found');
    }

    // Can only delete draft campaigns
    if (campaign.status !== 'draft') {
      throw new AppError(400, 'VALIDATION_ERROR', 'Can only delete draft campaigns');
    }

    await campaign.deleteOne();
    await CampaignRecipient.deleteMany({ campaignId });

    return { message: 'Campaign deleted successfully' };
  }

  async cancel(campaignId: string) {
    const campaign = await Campaign.findById(campaignId);

    if (!campaign) {
      throw new AppError(404, 'NOT_FOUND', 'Campaign not found');
    }

    if (campaign.status !== 'scheduled') {
      throw new AppError(400, 'VALIDATION_ERROR', 'Can only cancel scheduled campaigns');
    }

    campaign.status = 'cancelled';
    campaign.cancelledAt = new Date();
    await campaign.save();

    // Remove from queue
    // TODO: Implement queue job removal by searching for job with campaignId

    return campaign;
  }

  async start(campaignId: string, userId: string) {
    const campaign = await Campaign.findById(campaignId);

    if (!campaign) {
      throw new AppError(404, 'NOT_FOUND', 'Campaign not found');
    }

    // Can only start draft or scheduled campaigns
    if (!['draft', 'scheduled'].includes(campaign.status)) {
      throw new AppError(400, 'VALIDATION_ERROR', 'Campaign is not in a valid state to start');
    }

    // Get contacts from the list
    const members = await ContactListMember.find({ listId: campaign.listId });
    const contactIds = members.map(m => m.contactId);
    const contacts = await Customer.find({ _id: { $in: contactIds } });

    if (contacts.length === 0) {
      throw new AppError(400, 'VALIDATION_ERROR', 'No contacts found in the selected list');
    }

    console.log(`[Campaign ${campaignId}] Starting campaign for ${contacts.length} contacts`);

    // Update campaign status to sending
    campaign.status = 'sending';
    await campaign.save();

    // Get phone settings and AI behavior for the user
    const phoneSettings = await phoneSettingsService.get(userId);
    const aiBehavior = await aiBehaviorService.get(userId);

    // Get voice_id from selected voice
    const voiceId = VOICE_ID_MAP[phoneSettings.selectedVoice] || VOICE_ID_MAP['adam'];
    
    // Get transfer_to from phone settings and escalation_condition from AI behavior
    const transferTo = phoneSettings.humanOperatorPhone || '';
    const escalationCondition = aiBehavior.voiceAgent?.humanOperator?.escalationRules?.join('; ') || '';

    console.log(`[Campaign ${campaignId}] Using voice: ${phoneSettings.selectedVoice} (${voiceId})`);
    console.log(`[Campaign ${campaignId}] SIP Trunk ID: ${phoneSettings.livekitSipTrunkId}`);
    if (transferTo) {
      console.log(`[Campaign ${campaignId}] Transfer to: ${transferTo}`);
    }

    const COMM_API = process.env.COMM_API_URL || 'http://localhost:8000';
    const results: any[] = [];
    let successCount = 0;
    let failCount = 0;

    try {
      // Process each contact one by one
      for (let i = 0; i < contacts.length; i++) {
        const contact = contacts[i];
        console.log(`\n[Campaign ${campaignId}] Processing contact ${i + 1}/${contacts.length}: ${contact.name} (${contact.phone || contact.email})`);

        const contactResult: any = {
          contactId: contact._id,
          name: contact.name,
          phone: contact.phone,
          email: contact.email,
          call_status: null,
          sms_status: null,
          email_status: null,
          errors: [],
          transcript: null,
        };

        // 1. Make the call if requested
        if (campaign.communicationTypes.includes('call')) {
          if (!contact.phone) {
            console.error(`[Campaign ${campaignId}] Contact ${contact.name} has no phone number, skipping call`);
            contactResult.call_status = 'failed';
            contactResult.errors.push('No phone number available for call');
          } else {
            try {
              console.log(`[Campaign ${campaignId}] Initiating call to ${contact.phone}...`);
              
              // Prepare outbound call request body
              const callRequestBody: any = {
                phone_number: contact.phone,
                name: contact.name || 'Customer',
                dynamic_instruction: campaign.dynamicInstruction || '',
                language: campaign.language || 'en',
                voice_id: voiceId,
                sip_trunk_id: phoneSettings.livekitSipTrunkId,
              };

              // Add optional fields if they exist
              if (transferTo) {
                callRequestBody.transfer_to = transferTo;
              }
              if (escalationCondition) {
                callRequestBody.escalation_condition = escalationCondition;
              }

              const callResponse = await axios.post(`${COMM_API}/calls/outbound`, callRequestBody, {
                timeout: 360000, // 6 minutes timeout (call waits max 5 minutes for transcript)
              });

              contactResult.call_status = callResponse.data.status === 'success' ? 'success' : 'failed';
              contactResult.transcript = callResponse.data.transcript || null;

              console.log(`[Campaign ${campaignId}] Call to ${contact.phone} completed with status: ${contactResult.call_status}`);

              // Save transcript as conversation if available
              if (contactResult.transcript && Object.keys(contactResult.transcript).length > 0) {
                try {
                  await this.saveTranscriptAsConversation(
                    String(contact._id),
                    contactResult.transcript,
                    String(campaign._id)
                  );
                  console.log(`[Campaign ${campaignId}] Saved transcript for ${contact.name}`);
                } catch (transcriptError: any) {
                  console.error(`[Campaign ${campaignId}] Failed to save transcript for ${contact.name}:`, transcriptError.message);
                  // Don't fail the entire campaign if transcript saving fails
                }
              }
            } catch (error: any) {
              console.error(`[Campaign ${campaignId}] Call to ${contact.phone} failed:`, error.response?.data?.detail || error.message);
              contactResult.call_status = 'failed';
              contactResult.errors.push(`Call failed: ${error.response?.data?.detail || error.message}`);
            }
          }
        }

        // 2. Send Email if requested
        if (campaign.communicationTypes.includes('email')) {
          if (!contact.email) {
            console.error(`[Campaign ${campaignId}] Contact ${contact.name} has no email, skipping email`);
            contactResult.email_status = 'failed';
            contactResult.errors.push('No email address available');
          } else if (!campaign.emailBody || !campaign.emailBody.subject || !campaign.emailBody.body) {
            console.error(`[Campaign ${campaignId}] Email subject/body not configured, skipping email`);
            contactResult.email_status = 'failed';
            contactResult.errors.push('Email subject or body not configured');
          } else {
            try {
              console.log(`[Campaign ${campaignId}] Sending email to ${contact.email}...`);
              const emailResponse = await axios.post(`${COMM_API}/email/send`, {
                receiver_email: contact.email,
                subject: campaign.emailBody.subject,
                body: campaign.emailBody.body,
                is_html: campaign.emailBody.is_html || false,
              }, {
                timeout: 30000, // 30 seconds timeout
              });

              contactResult.email_status = emailResponse.data.status === 'success' ? 'success' : 'failed';
              console.log(`[Campaign ${campaignId}] Email to ${contact.email} completed with status: ${contactResult.email_status}`);
            } catch (error: any) {
              console.error(`[Campaign ${campaignId}] Email to ${contact.email} failed:`, error.response?.data?.detail || error.message);
              contactResult.email_status = 'failed';
              contactResult.errors.push(`Email failed: ${error.response?.data?.detail || error.message}`);
            }
          }
        }

        // 3. Send SMS if requested
        if (campaign.communicationTypes.includes('sms')) {
          if (!contact.phone) {
            console.error(`[Campaign ${campaignId}] Contact ${contact.name} has no phone number, skipping SMS`);
            contactResult.sms_status = 'failed';
            contactResult.errors.push('No phone number available for SMS');
          } else if (!campaign.smsBody || !campaign.smsBody.message) {
            console.error(`[Campaign ${campaignId}] SMS message not configured, skipping SMS`);
            contactResult.sms_status = 'failed';
            contactResult.errors.push('SMS message not configured');
          } else {
            try {
              console.log(`[Campaign ${campaignId}] Sending SMS to ${contact.phone}...`);
              const smsResponse = await axios.post(`${COMM_API}/sms/send`, {
                body: campaign.smsBody.message,
                number: contact.phone,
              }, {
                timeout: 30000, // 30 seconds timeout
              });

              contactResult.sms_status = smsResponse.data.status === 'success' ? 'success' : 'failed';
              console.log(`[Campaign ${campaignId}] SMS to ${contact.phone} completed with status: ${contactResult.sms_status}`);
            } catch (error: any) {
              console.error(`[Campaign ${campaignId}] SMS to ${contact.phone} failed:`, error.response?.data?.detail || error.message);
              contactResult.sms_status = 'failed';
              contactResult.errors.push(`SMS failed: ${error.response?.data?.detail || error.message}`);
            }
          }
        }

        // Determine overall status for this contact
        const anySuccess = contactResult.call_status === 'success' || 
                          contactResult.email_status === 'success' || 
                          contactResult.sms_status === 'success';
        
        if (anySuccess) {
          successCount++;
        } else {
          failCount++;
        }

        results.push(contactResult);

        // Create campaign recipient record
        try {
          await CampaignRecipient.create({
            campaignId: campaign._id,
            contactId: contact._id,
            status: anySuccess ? 'sent' : 'failed',
            sentAt: new Date(),
            failureReason: contactResult.errors.length > 0 ? JSON.stringify(contactResult.errors) : undefined,
          });
        } catch (recipientError: any) {
          console.error(`[Campaign ${campaignId}] Failed to save recipient record for ${contact.name}:`, recipientError.message);
        }

        console.log(`[Campaign ${campaignId}] Completed processing contact ${contact.name}. Success: ${anySuccess ? 'Yes' : 'No'}`);
      }

      // Update campaign status to sent
      campaign.status = 'sent';
      campaign.sentAt = new Date();
      await campaign.save();

      console.log(`\n[Campaign ${campaignId}] Campaign completed. Success: ${successCount}, Failed: ${failCount}`);

      return {
        campaign,
        results: {
          total: contacts.length,
          success: successCount,
          failed: failCount,
          details: results,
        },
      };
    } catch (error: any) {
      console.error(`[Campaign ${campaignId}] Campaign failed with error:`, error.message);
      
      // Update campaign status to failed
      campaign.status = 'failed';
      await campaign.save();

      throw new AppError(500, 'CAMPAIGN_ERROR', error.message || 'Failed to execute campaign');
    }
  }

  // Helper method to save call transcript as conversation with messages
  private async saveTranscriptAsConversation(
    customerId: string,
    transcript: Record<string, any>,
    campaignId: string
  ) {
    try {
      console.log(`[Transcript] Raw transcript structure:`, JSON.stringify(transcript, null, 2));
      
      // Create conversation
      const conversation = await Conversation.create({
        customerId,
        channel: 'phone',
        status: 'closed',
        transcript,
        campaignId,
        isAiManaging: true,
        unread: false,
      });

      console.log(`[Transcript] Created conversation ${conversation._id} for customer ${customerId}`);

      // Parse transcript and create message records
      const messages: any[] = [];
      let transcriptArray: any[] = [];

      // Try to extract messages from different transcript formats
      if (Array.isArray(transcript)) {
        console.log(`[Transcript] Format: Array with ${transcript.length} items`);
        transcriptArray = transcript;
      } else if (typeof transcript === 'object') {
        // Check for common formats
        if (transcript.items && Array.isArray(transcript.items)) {
          console.log(`[Transcript] Format: Object with items array (${transcript.items.length} items)`);
          transcriptArray = transcript.items;
        } else if (transcript.turns && Array.isArray(transcript.turns)) {
          console.log(`[Transcript] Format: Object with turns array (${transcript.turns.length} turns)`);
          transcriptArray = transcript.turns;
        } else if (transcript.messages && Array.isArray(transcript.messages)) {
          console.log(`[Transcript] Format: Object with messages array (${transcript.messages.length} messages)`);
          transcriptArray = transcript.messages;
        } else if (transcript.conversation && Array.isArray(transcript.conversation)) {
          console.log(`[Transcript] Format: Object with conversation array (${transcript.conversation.length} items)`);
          transcriptArray = transcript.conversation;
        } else {
          // Try object keys as indices (e.g., {"0": {...}, "1": {...}})
          const keys = Object.keys(transcript).filter(key => !isNaN(Number(key))).sort((a, b) => Number(a) - Number(b));
          if (keys.length > 0) {
            console.log(`[Transcript] Format: Object with numeric keys (${keys.length} entries)`);
            transcriptArray = keys.map(key => transcript[key]);
          } else {
            console.log(`[Transcript] Format: Unknown object format. Keys:`, Object.keys(transcript));
          }
        }
      } else {
        console.log(`[Transcript] Format: Unexpected type - ${typeof transcript}`);
      }

      console.log(`[Transcript] Parsed ${transcriptArray.length} transcript entries`);

      // Convert transcript entries to messages
      for (let i = 0; i < transcriptArray.length; i++) {
        const entry = transcriptArray[i];
        console.log(`[Transcript] Entry ${i}:`, JSON.stringify(entry, null, 2));
        
        let sender: 'customer' | 'ai' = 'customer';
        let text = '';

        // Determine sender and text based on different formats
        if (entry.role === 'user' || entry.role === 'customer' || entry.sender === 'user') {
          sender = 'customer';
        } else if (entry.role === 'assistant' || entry.role === 'ai' || entry.sender === 'assistant' || entry.sender === 'ai') {
          sender = 'ai';
        } else {
          console.log(`[Transcript] Warning: Unknown sender type in entry ${i}. Entry:`, entry);
        }

        // Extract text - handle both string and array formats
        if (entry.content) {
          if (Array.isArray(entry.content)) {
            // Content is an array of strings, join them
            text = entry.content.join(' ');
          } else if (typeof entry.content === 'string') {
            text = entry.content;
          }
        } else {
          text = entry.text || entry.message || '';
        }

        if (text && text.trim()) {
          const message = {
            conversationId: conversation._id,
            sender,
            text: text.trim(),
            type: 'message',
            attachments: [],
            sourcesUsed: [],
            topics: [],
            timestamp: entry.timestamp ? new Date(entry.timestamp) : new Date(),
          };
          messages.push(message);
          console.log(`[Transcript] Created message ${i + 1}:`, { sender, textLength: text.length });
        } else {
          console.log(`[Transcript] Warning: No text found in entry ${i}`);
        }
      }

      // Save all messages
      if (messages.length > 0) {
        const savedMessages = await Message.insertMany(messages);
        console.log(`[Transcript] ✅ Successfully created ${messages.length} messages for conversation ${conversation._id}`);
        console.log(`[Transcript] Sample saved message:`, {
          _id: savedMessages[0]._id,
          conversationId: savedMessages[0].conversationId,
          conversationIdType: typeof savedMessages[0].conversationId,
          sender: savedMessages[0].sender,
        });
        
        // Verify messages can be queried back
        const verifyCount = await Message.countDocuments({ conversationId: conversation._id });
        console.log(`[Transcript] Verification: Found ${verifyCount} messages with conversationId query`);
      } else {
        console.log(`[Transcript] ⚠️ No messages created from transcript!`);
      }

      return conversation;
    } catch (error: any) {
      console.error('[Transcript] ❌ Error saving transcript as conversation:', error.message);
      console.error('[Transcript] Error stack:', error.stack);
      throw error;
    }
  }

  async getAnalytics(campaignId: string) {
    const campaign = await Campaign.findById(campaignId);

    if (!campaign) {
      throw new AppError(404, 'NOT_FOUND', 'Campaign not found');
    }

    const recipients = await CampaignRecipient.find({ campaignId }).lean();

    const stats = {
      sent: recipients.filter(r => r.status !== 'pending' && r.status !== 'failed').length,
      delivered: recipients.filter(r => r.deliveredAt).length,
      failed: recipients.filter(r => r.status === 'failed').length,
      opened: recipients.filter(r => r.openedAt).length,
      clicked: recipients.filter(r => r.clickedAt).length,
      replied: recipients.filter(r => r.repliedAt).length,
      openRate: 0,
      clickRate: 0,
      replyRate: 0
    };

    if (stats.delivered > 0) {
      stats.openRate = (stats.opened / stats.delivered) * 100;
      stats.clickRate = (stats.clicked / stats.delivered) * 100;
      stats.replyRate = (stats.replied / stats.delivered) * 100;
    }

    // Get timeline
    const timeline = await CampaignRecipient.aggregate([
      { $match: { campaignId: campaign._id } },
      {
        $group: {
          _id: {
            $dateToString: {
              format: '%Y-%m-%d %H:00',
              date: '$sentAt'
            }
          },
          count: { $sum: 1 }
        }
      },
      { $sort: { _id: 1 } }
    ]);

    return {
      campaignId,
      stats,
      timeline
    };
  }

  private async getCampaignStats(campaignId: any) {
    const recipients = await CampaignRecipient.find({ campaignId }).lean();

    return {
      sent: recipients.filter(r => r.status !== 'pending' && r.status !== 'failed').length,
      delivered: recipients.filter(r => r.deliveredAt).length,
      failed: recipients.filter(r => r.status === 'failed').length,
      opened: recipients.filter(r => r.openedAt).length,
      clicked: recipients.filter(r => r.clickedAt).length,
      replied: recipients.filter(r => r.repliedAt).length
    };
  }

  private async scheduleCampaign(campaignId: string, scheduledAt: Date) {
    if (!campaignQueue) {
      throw new AppError(503, 'SERVICE_UNAVAILABLE', 'Campaign queue is not available. Redis must be running to schedule campaigns.');
    }

    const delay = scheduledAt.getTime() - Date.now();

    if (delay <= 0) {
      // Send immediately
      await campaignQueue.add('send-campaign', { campaignId });
    } else {
      // Schedule for later
      await campaignQueue.add('send-campaign', { campaignId }, { delay });
    }
  }

  async getTemplates() {
    // Return mock templates or fetch from WhatsApp API
    return [
      {
        id: 'template_1',
        name: 'order_confirmation',
        language: 'en',
        status: 'approved',
        category: 'transactional',
        components: [
          {
            type: 'HEADER',
            format: 'TEXT',
            text: 'Order Confirmation'
          },
          {
            type: 'BODY',
            text: 'Hi {{1}}, your order {{2}} has been confirmed.'
          }
        ],
        variables: ['customer_name', 'order_number']
      },
      {
        id: 'template_2',
        name: 'welcome_message',
        language: 'en',
        status: 'approved',
        category: 'marketing',
        components: [
          {
            type: 'HEADER',
            format: 'TEXT',
            text: 'Welcome!'
          },
          {
            type: 'BODY',
            text: 'Hi {{1}}, welcome to our platform. We are excited to have you!'
          }
        ],
        variables: ['customer_name']
      },
      {
        id: 'template_3',
        name: 'promotional_offer',
        language: 'en',
        status: 'approved',
        category: 'marketing',
        components: [
          {
            type: 'HEADER',
            format: 'TEXT',
            text: 'Special Offer!'
          },
          {
            type: 'BODY',
            text: 'Hi {{1}}, get {{2}}% off on your next purchase. Valid until {{3}}.'
          }
        ],
        variables: ['customer_name', 'discount_percentage', 'expiry_date']
      }
    ];
  }
}

export const campaignService = new CampaignService();

